# Zeyu Zhao
# Nov. 26, 2016
# Tested in Maple 2016
# Published under License: GNU GPL 3.0
# Please Open This Text File as MAPLE INPUT

print(`Fast Sudoku Puzzle Generator by Zeyu Zhao`):
print(`Type: SudokuGen() to generate a random Sudoku puzzle`):
print(`Type: SudokuSol(puzzle) to solve a puzzle. (Let Unknown cell 0)`):
print(`Type: ExamplePuzzle to see an example puzzle.`):
print(`Type: GenTimeCost() to calculate average CPU time cost for generating one random puzzle.`):
print(`Type: SolTimeCost(puzzle) to calculate average CPU time cost for solving the given puzzle.`):

ExamplePuzzle:=[[1, 0, 3, 0, 6, 9, 0, 5, 0], [0$9], [0, 0, 5, 0, 2, 8, 1, 0, 9], 
[6, 0, 9, 0, 4, 0, 0, 1, 0], [0$9], [0, 1, 0, 9, 8, 3, 5, 0, 6], 
[0$9], [7, 0, 0, 0, 3, 1, 0, 9, 0], [0$9]]:

with(combinat, randperm):

EID:=proc(r,c)
	return (r-1)*9+c:
end proc:

RCIndex:=proc(i)
	local R,C:
	R:=floor((i-1)/9)+1:
	C:=i-9*(R-1):
	return [R,C]:
end proc:

BlockIndex:=proc(i)
	local rc,rn,cn:
	rc:=RCIndex(i):
	rn:=floor((rc[1]-1)/3):
	cn:=floor((rc[2]-1)/3):
	return rn*3+cn+1:
end proc:
	
BlockElement:=[[]$9]:
RowElement:=[[]$9]:
ColumnElement:=[[]$9]:
CurrentMap:=[[0$9]$9]:
CurrentAvail:=[{}$81]:
for i from 1 to 81 do:
	rc:=RCIndex(i):
	b:=BlockIndex(i):
	BlockElement[b]:=[op(BlockElement[b]),i]:
	RowElement[rc[1]]:=[op(RowElement[rc[1]]),i]:
	ColumnElement[rc[2]]:=[op(ColumnElement[rc[2]]),i]:
end do:

#Remove avaliable choices of other cells after filling num to cell id.
RemoveOption:=proc(id,num)
	global CurrentAvail:
	local RC, B, i,listnum:
	RC:=RCIndex(id):
	B:=BlockIndex(id):
	for i from 1 to 9 do:
		CurrentAvail[RowElement[RC[1]][i]]:=CurrentAvail[RowElement[RC[1]][i]] minus {num}:
		CurrentAvail[ColumnElement[RC[2]][i]]:=CurrentAvail[ColumnElement[RC[2]][i]] minus {num}:
		CurrentAvail[BlockElement[B][i]]:=CurrentAvail[BlockElement[B][i]] minus {num}:
	end do:
	return:
end proc:

#Add avaliable choices of other cells after removing num to cell id.
AddOption:=proc(id,num)
	global CurrentAvail:
	local RC, B, i,listnum:
	RC:=RCIndex(id):
	B:=BlockIndex(id):
	for i from 1 to 9 do:
		CurrentAvail[RowElement[RC[1]][i]]:=CurrentAvail[RowElement[RC[1]][i]] union {num}:
		CurrentAvail[ColumnElement[RC[2]][i]]:=CurrentAvail[ColumnElement[RC[2]][i]] union {num}:
		CurrentAvail[BlockElement[B][i]]:=CurrentAvail[BlockElement[B][i]] union {num}:
	end do:
	return:
end proc:

#Find Optimal Location to Search: -1: Finished; -9: Infeasible
OptimalLoc:=proc()
	global CurrentAvail, CurrentMap:
	local i,min,minloc,RC:
	min:=10:
	minloc:=-1:
	for i from 1 to 81 do:
		RC:=RCIndex(i):
		if nops(CurrentAvail[i])<min and CurrentMap[RC[1]][RC[2]]=0 then:
			min:=nops(CurrentAvail[i]):
			if min <= 0 then:
				#STOP: solution infeasible
				return -9:
			end if:
			minloc:=i:
		end if:
	end do:
	return minloc:
end proc:
			
#Depth First Search - Backtracking
DFS:=proc(id)
	global CurrentMap, CurrentAvail:
	local orderlist,i,RC,nextloc:
	#Random Generation
	orderlist:=randperm(CurrentAvail[id]):
	RC:=RCIndex(id):
	for i from 1 to nops(orderlist) do:
		CurrentMap[RC[1]][RC[2]]:=orderlist[i]:
		RemoveOption(id,orderlist[i]):
		nextloc:=OptimalLoc():
		if nextloc=-1 then:
			#Indicate final state
			return nextloc:
		end if:
		if nextloc=-9 then:
			#Prune search tree
			AddOption(id,orderlist[i]):
		else:
			if DFS(nextloc)=-1 then:
				return -1:
			end if:
			AddOption(id,orderlist[i]):
		end if:
	end do:
	CurrentMap[RC[1]][RC[2]]:=0:
	return -9:
end proc:
			
		
SudokuGen:=proc()
	local i:
	global CurrentMap,CurrentAvail:
	CurrentMap:=[randperm(9),[0$9]$8]:
	CurrentAvail:=[{seq(1 .. 9)}$81]:
	for i from 1 to 9 do:
		RemoveOption(i,CurrentMap[1][i]):
	end do:
	#Search the 10-th cell
	DFS(10):
	return(CurrentMap):
end proc:

SudokuSol:=proc(puzzle)
	local i,rc:
	global CurrentMap,CurrentAvail:
	CurrentMap:=puzzle:
	CurrentAvail:=[{seq(1 .. 9)}$81]:
	for i from 1 to 81 do:
		rc:=RCIndex(i):
		if CurrentMap[rc[1]][rc[2]]<>0 then:
			RemoveOption(i,CurrentMap[rc[1]][rc[2]]):
		end if:
	end do:
	i:=OptimalLoc():
	if i=-1 then:
		return `Input Puzzle is Complete!`:
	end if:
	if i=-9 then:
		return `No Solution`:
	end if:
	if DFS(i)=-1 then:
		return CurrentMap:
	else:
		return `No Solution`:
	end if:
end proc:

GenTimeCost:=proc()
	local t,i:
	t:=0.0:
	print(`Generating 100 random puzzles. Please wait...`):
	for i from 1 to 100 do:
		t:=t+time(SudokuGen()):
	end do:
	return t/100.0:
end proc:

SolTimeCost:=proc(puzzle)
	local t,i:
	t:=0.0:
	print(`Solving the given puzzle for 100 times. Please wait...`):
	for i from 1 to 100 do:
		t:=t+time(SudokuSol(puzzle)):
	end do:
	return t/100.0:
end proc: